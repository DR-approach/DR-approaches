# C++基础知识

## C和C++的区别

设计思想上：

C++是面向对象的语言

C是结构化编程语言

语法上：

C++具有封装、继承、多态三种特性

可以使用抽象数据类型进行基于对象的编程

可以使用多态进行面向对象的编程

可以负担的起以模板为特征的泛型编程



## C++和python的区别

1、C++为编译型语言，python为解释型的脚本语言

C++先将源代码编译成目标语言，再连接到目标程序执行

C++从源代码到可执行文件，一般经过以下4个步骤：

1）预处理

2）编译，产生汇编文件

3）汇编，产生目标文件

4）链接，产生可执行文件（.exe文件）



Python由解释器根据输入的数据当场执行而不生成任何的目标程序，如在终端上打一条命令或语句，解释程序就立即将此语句解释成一条或几条指令并提交硬件立即执行且将执行结果反映到终端，从终端把命令打入后，就能立即得到计算结果。这的确是很方便的，很适合于一些小型机的计算问题。但解释程序执行速度很慢。



## C++11的新特性

1、auto关键字

2、nullptr关键字

3、智能指针：shared_ptr、unique_ptr

4、新增STL容器：array、unordered_map

map： map内部实现了一个红黑树（红黑树是非严格平衡二叉搜索树，而AVL是严格平衡二叉搜索树），红黑树具有自动排序的功能，因此map内部的所有元素都是有序的，红黑树的每一个节点都代表着map的一个元素。因此，对于map进行的查找，删除，添加等一系列的操作都相当于是对红黑树进行的操作。map中的元素是按照二叉搜索树（又名二叉查找树、二叉排序树，特点就是左子树上所有节点的键值都小于根节点的键值，右子树所有节点的键值都大于根节点的键值）存储的，使用中序遍历可将键值按照从小到大遍历出来。
unordered_map: unordered_map内部实现了一个哈希表（也叫散列表，通过把关键码值映射到Hash表中一个位置来访问记录，查找的时间复杂度可达到O(1)，其在海量数据处理中有着广泛应用）。因此，其元素的排列顺序是无序的。



## C++中的智能指针

智能指针主要是用来管理堆上分配的内存。智能指针就是一个栈对象，当栈对象的生命周期结束时，会自动调用析构函数释放掉申请的内存，从而防止内存泄漏。C++中最常用的智能指针是shared_ptr，它采用引用计数的方法，记录当前内存资源被多少个智能指针引用。当引用记数为0时，智能指针会自动释放掉引用的内存资源。对shared_ptr初始化不能将一个普通指针直接赋值给智能指针。因为一个是指针，一个是类。可以通过make_shared函数或者构造函数传入普通指针。通过get函数获得普通指针。Unique_ptr实现独占式拥有概念，保证同一时间内只有一个智能指针可以指向该对象。





## C++的多态

在基类函数前加上virtual关键字，在派生类函数中重写该函数

1）虚函数是类的成员函数

2）存在虚函数的类都有一个一维的虚函数表

3）多态性是一个接口的多种实现，是面向对象的核心



## C++中内存的基本构造

1、C++中的内存分为5个区：栈、堆、全局/静态存储区、常量存储器和代码区

1、栈：由编译器需要时自动分配，不需要是自动清除变量，如局部参数，函数变量等

2、堆：由new关键字分配的内存，忘记由delete释放可能会造成内存泄漏

3、全局/静态存储区 ：全局变量和静态变量被分配到同一块内存中

4、常量存储区：里面存放的是常量，不允许修改

5、代码区：存放代码，不允许执行，但可以修改



## static的优势：

可以节省内存，因为它是所有对象所公有的，因此，对多个对象来说，静态数据成员只存储一处，供所有对象共用。静态数据成员的值对每个对象都是一样，但它的值是可以更新的。只要对静态数据成员的值更新一次，保证所有对象存取更新后的相同的值，这样可以提高时间效率。




## 为什么构造函数不能是虚函数？

虚函数需要有一个虚函数表与之对应。可是当对象还没有实例化的时候，内存空间中还不存在虚函数表。



## Vector和List的区别

Vector为存储的对象分配了一段连续的地址空间，list中的对象是离散存储的。

Vector适用：对象数量变化少，简单对象，随机访问元素频繁
List适用：对象数量变化大，对象复杂，插入和删除频繁
最大的区别是,list是双向的，而vector是单向的



## 单例模式

懒汉式

public class Single{

private static Single instance;

private Single(){};

public static synchronized Single getinstance(){

if(instance==null){

instance=new Single()};

} 

return instance;

}





饿汉式

public class Singleton {  
private static Singleton instance = new Singleton();  
private Singleton (){}  
public static Singleton getInstance() {  
return instance;  
}  
}







# 计算机网络基础知识



## 从输入URL到网页呈现的过程

1、域名解析：解析为IP地址，叫做DNS解析

2、TCP连接：包括三次握手

3、浏览器发送http请求：发送请求报文

4、服务器处理http请求：返回响应报文

5、浏览器页面渲染：解析html文档，渲染页面

6、断开TCP连接：四次挥手，断开连接





## GET和POST的区别

get是从服务器上获取数据，post是上传到服务器上

get传送数据很小，有长度限制；post没有长度限制

get安全性低，参数暴露在url中；post安全性高，通过request body传递参数



## TCP和UDP的区别

UDP用户数据报协议是无连接的，尽最大可能交付。没有拥塞控制，面向报文。支持1对1，多对多。

TCP传输控制协议面向连接，提供可靠交付。有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看出字节流）。只能是点对点的、



## TCP的三次握手	

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

如果第三次握手迟迟不来，服务器会认为这次连接是无效的，释放相关资源。



## TCP的四次挥手

服务器第一次收到断开连接的请求后，会进入close-wait状态，服务器能传给客户端，反之不能。这是为了让服务器发送还未发送完毕的数据。发送完毕后，服务器发送FIN报文，释放连接。



## TCP是怎么实现可靠传输的

TCP使用超时重传来实现可靠传输。如果一个已经发送的报文规定时间内没有收到确认，那么就重传这个报文段。



## HTTP和HTTPS 的区别

1、HTTPS协议需要申请证书，而免费证书较少，因此需要一定的费用

2、HTTP中的信息是明文传输，保密性差；不验证通讯双方的身份，身份可能会遭遇伪装；无法证明明文的完整性，报文有可能遭到篡改。

3、HTTPS具有加密，认证和完整性保护的特点



## HTTP1.0和1.1的区别

1、缓存处理：1.1提供了更多的缓存处理策略

2、带宽优化及网络连接的使用：1.1可以只请求资源的某个部分

3、错误通知的管理：新增了24个错误状态相应码

4、HOST域，识别虚拟主机

5、支持长连接，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟



## TCP拥塞控制

发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量

### 1. 慢开始与拥塞避免

发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 ...

注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd >= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。

如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。

### 2. 快重传与快恢复

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd = ssthresh，注意到此时直接进入拥塞避免。

慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。





# 操作系统基础知识

## 僵尸进程

僵尸进程是子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程会变成一个僵尸进程。如果结束父进程，让僵尸进程变成孤儿进程，这是孤儿进程会被init进程回收，释放其占有的资源。



## 进程和线程的区别

1、资源

进程是资源分配的基本单位，线程不拥有资源，但是可以使用隶属于进程的资源



2、调度

线程是独立调度的基本单位。同一进程中，线程的切换不会影响进程的切换。



3、系统开销

创建和撤销进程时，系统都要为之分配和回收资源，如内存空间、IO设备等，所付出的开销远大于创建和撤销线程的开销。



4、通讯

线程可以直接通过读写同一进程内的资源进行通信，而进程通信必须使用进程通信方法。



## 进程通信

1、管道

管道是通过pipe函数创建的，fd[0]用于读，fd[1]用于写

具有以下限制：

​	只支持半双工通信；只能在父子进程和兄弟进程中使用



2、FIFO（命名管道）

去除了管道只能在父子进程中使用的限制。常用于客户进程和服务器进程之间传递数据。



3、消息队列

相比于FIFO，消息队列具有以下优点：

消息队列独立于读写进程存在，避免了打开关闭管道时可能产生的困难；

避免了FIFO的同步阻塞问题，不需要进程自己提供同步方法；

读进程可以根据消息类型有选择的接收消息。



4、信号量

它是一个计数器，用于为多个进程提供对共享数据的访问



5、共享存储

允许多个进程共享一个给定的存储区，因为数据不需要在进程之间复制，所以这是最快的一种IPC。需要使用信号量来同步对共享存储的访问。



6、socket套接字

与其他通信机制不同，它可以用于不同机器间的通信。



## 死锁

1、死锁的必要条件

1）互斥：一段时间内某资源仅为一个进程所占有

2）不可剥夺：进程获得的资源在使用完之前，不能被其他进程强行夺走

3）请求与保持：进程已经保持了一个资源，但又提出了新的资源请求，但是该资源被其他进程所占有，这时候请求进程阻塞，但对自己获得的资源不放。

4）循环等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。



## I/O模型

1、阻塞型：请求数据时，如果数据还没有就绪，就会一直等到数据就绪

2、非阻塞型：不断的询问内核数据是否准备完毕，会一直占用CPU，浪费资源

3、多路复用型：select、poll、epoll三组系统。通过将多个文件描述符传递给这三个系统，通过它们来检测fd是否出去就绪状态。select和poll是顺序扫描fd是否准备就绪，支持的fd数量有限。epoll是基于事件驱动，因此性能更高，当fd就绪时会立刻回应。

4、信号驱动型：让内核在数据就绪时，发送信号通知我们，将数据从内核复制到应用进程中。

5、异步I/O：用户进程发送I/O请求后，可以去做其他事情。但内核完成数据拷贝之后，告诉用户进程IO操作已经完成，可以使用数据了。



## select、epoll、poll的区别

1、select

它只能知道有I/O事件发生，却不知道是哪个。应用程序需要无差别的轮询所有文件描述符，才能找到目标目标事件。



2、poll

和select类似，但是没有最大连接数的限制。使用链表来存储所有文件描述符。



3、epoll

epoll会把哪个流上发生什么样的I/O事件通知我们，是事件驱动的。



三者的应用场景：

1、select的timeout参数是微秒级的，poll和epoll是毫秒，因此select更加适用于实时性要求高的场景，比如核反应堆。最重要的，select可移植性好，几乎被所有主流平台支持。



2、poll没有最大描述符数量的限制，如果平台支持并且对实时性要求不高，应该使用poll



3、epoll。适用于只需要运行在linux平台，有大量描述符需要同时问询，最好是长连接。如果监控的描述符小于1000，则没有必要用epoll。如果需要监听的描述符很多，而且都是比较短暂的，也没有必要使用epoll。因为epoll的所有描述符都存储在内核中，如果频繁改变描述符的状态，都要通过系统调用，频繁调用会降低效率。并且存储在内核中的描述符不容易调试。



## 用户态和内核态的区别

最关键的工作必须交给特权级最高的进程去执行，这样可以做到集中管理，减少有限资源的访问和使用冲突。

用户运行一个程序，该程序创建的进程开始时运行自己的代码，处于用户态。如果要执行文件操作、网络数据发送等操作必须通过write、send等系统调用，这些系统调用会调用内核的代码。进程会切换到Ring0，然后进入3G-4G中的内核地址空间去执行内核代码来完成相应的操作。内核态的进程执行完后又会切换到Ring3，回到用户态。这样，用户态的程序就不能随意操作内核地址空间，具有一定的安全保护作用。这说的保护模式是指通过内存页表操作等机制，保证进程间的地址空间不会互相冲突，一个进程的操作不会修改另一个进程地址空间中的数据。

用户态切换到内核态的三种方式

1、系统调用

这是用户态进程主动要求切换到内核态的一种方式。用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作。

2、异常

当cpu在执行运行在用户态下的程序时，发生了一些没有预知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常。

3、外围设备的中断

当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令而转到与中断信号对应的处理程序去执行，如果前面执行的指令时用户态下的程序，那么转换的过程自然就会是 由用户态到内核态的切换。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。



用户态到内核态具体的切换步骤：

（1）从当前进程的描述符中提取其内核栈的ss0及esp0信息。

（2）使用ss0和esp0指向的内核栈将当前进程的cs,eip,eflags,ss,esp信息保存起来，这个过程也完成了由用户栈到内核栈的切换过程，同时保存了被暂停执行的程序的下一条指令。

（3）将先前由中断向量检索得到的中断处理程序的cs,eip信息装入相应的寄存器，开始执行中断处理程序，这时就转到了内核态的程序执行了。

​	





# 数据库基础知识

## ACID4个特性

原子性

事务是数据库逻辑工作单位，事务中的操作要么都做要么都不做

隔离性

一个事务的执行不能被其他事务干扰

持久性

事务对数据库的改变是永久的

一致性

事务的执行结果必须是使数据库从一个一致状态转变到另一个一致状态



## 并发一致性问题

**脏读：**当前事务读到其他事务未提交的数据。

**不可重复读：**一次事务内多次读取同一数据。但是在两次读取的间隔中，另一个事务对数据进行了修改，因此读到了不一样的数据

**幻读：**一个事务读取某个范围内的数据，另一个事务插入了一个数据，再次读取这个范围的数据，结果不一样 



为了解决并发一致性问题：

**两段锁协议：**

两段锁协议是保证事务可串行化的充分条件。可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。









## 4种隔离级别

后三种隔离级别，可以依次解决脏读，不可重复读，幻读。

1、读未提交

会出现脏读的问题。解决方案，写数据的时候添加一个X锁。

2、读已提交

会出现不可重复读的问题。读数据的时候加一个S锁，且两个锁不能同时加。

3、可重复读

会出现幻读问题。事务提交才释放S锁。

4、可串行化

事务只能一件一件进行。





## B树、B+树、红黑树的区别

文件系统及数据库系统普遍采用 B+ Tree 作为索引结构, 这是因为使用 B+ 树访问磁盘数据有更高的性能。

（一）B+ 树有更低的树高

平衡树的树高 O(h)=O(logdN)，其中 d 为每个节点的出度。红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多。

（二）磁盘访问原理

操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。

如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+ 树相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以 B+ 树更适合磁盘数据的读取。

（三）磁盘预读特性

为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。



## MVCC多版本并发控制

MVCC 的多版本指的是多个版本的快照，快照存储在 **Undo 日志**中，该日志通过回滚指针 ROLL_PTR 把一个数据行的所有快照连接起来。



MVCC 还维护了一个 ReadView 结构，主要包含了当前系统未提交的事务列表 TRX_IDs {TRX_ID_1, TRX_ID_2, ...}，还有该列表的最小值 TRX_ID_MIN 和 TRX_ID_MAX。



在进行 SELECT 操作时，根据数据行快照的 TRX_ID 与 TRX_ID_MIN 和 TRX_ID_MAX 之间的关系，从而判断数据行快照是否可以使用：

- TRX_ID < TRX_ID_MIN，表示该数据行快照时在当前所有未提交事务之前进行更改的，因此可以使用。
- TRX_ID > TRX_ID_MAX，表示该数据行快照是在事务启动之后被更改的，因此不可使用。
- TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX，需要根据隔离级别再进行判断：
  - 提交读：如果 TRX_ID 在 TRX_IDs 列表中，表示该数据行快照对应的事务还未提交，则该快照不可使用。否则表示已经提交，可以使用。
  - 可重复读：都不可以使用。因为如果可以使用的话，那么其它事务也可以读到这个数据行快照并进行修改，那么当前事务再去读这个数据行得到的值就会发生改变，也就是出现了不可重复读问题。

在数据行快照不可使用的情况下，需要沿着 Undo Log 的回滚指针 ROLL_PTR 找到下一个快照，再进行上面的判断。



#### 1. 快照读

MVCC 的 SELECT 操作是快照中的数据，不需要进行加锁操作

#### 2. 当前读

MVCC 其它会对数据库进行修改的操作（INSERT、UPDATE、DELETE）需要进行加锁操作，从而读取最新的数据。可以看到 MVCC 并不是完全不用加锁，而只是避免了 SELECT 的加锁操作。





## 索引

#### 1. B+Tree 索引

是大多数 MySQL 存储引擎的默认索引类型。

因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。

因为 B+ Tree 的有序性，所以除了用于查找，还可以用于排序和分组。

可以指定多个列作为索引列，多个索引列共同组成键。

适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。

InnoDB 的 B+Tree 索引分为主索引和辅助索引。

主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为**聚簇索引。**因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。



辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。



#### 2. 哈希索引

哈希索引能以 O(1) 时间进行查找，但是失去了有序性：

- 无法用于排序与分组；
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。



### 索引的优点

- 大大减少了服务器需要扫描的数据行数。
- 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，不需要排序和分组，也就不需要创建临时表）。
- 将随机 I/O 变为顺序 I/O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。

### 索引的使用条件

- 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效；
- 对于中到大型的表，索引就非常有效；
- 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。





### 